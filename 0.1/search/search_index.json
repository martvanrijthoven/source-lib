{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SourceLib Documentation","text":""},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install sourcelib\n</code></pre>"},{"location":"#overview","title":"Overview","text":"<ul> <li>Collecting Files</li> <li>Reference</li> </ul>"},{"location":"working-with-associations/","title":"Working with Associations","text":"<p>Files are everywhere. This module helps you match related ones, no matter their type or location.</p>"},{"location":"working-with-associations/#introducing-associators-our-way-to-define-relations","title":"Introducing Associators: Our Way to Define Relations","text":"<p>Central to this module is the concept of Associators, which are functions or objects that take in a file path and return a key which represents a category or group that the file belongs to.</p>"},{"location":"working-with-associations/#the-simplest-associator-stem_file_associater","title":"The Simplest Associator: stem_file_associater","text":"<p>To group files by their names without considering extensions, use this associator. Give it a file, and it provides the stem (the filename without its extension).</p>"},{"location":"working-with-associations/#going-one-step-beyond-stemsplitterassociater","title":"Going One Step Beyond: StemSplitterAssociater","text":"<p>To group files using a segment of their name, such as matching between data_2023.txt and overview_2023.pdf, use StemSplitterAssociater. It allows you to pick delimiter symbols (like _) to segment the filename for categorization e.g., in this case the year 2023.</p>"},{"location":"working-with-associations/#bringing-files-together-the-associations-class","title":"Bringing Files Together: The Associations Class","text":"<p>Now that we have a way to generate keys for files, it's time to put them together. The <code>Associations</code> class is a container that allows you to group files under their respective keys.</p>"},{"location":"working-with-associations/#managing-individual-groupings-with-associatedfiles","title":"Managing Individual Groupings with AssociatedFiles","text":"<p>With a method in place for creating file keys, we introduce the Associations class. It organizes files under their corresponding keys.</p>"},{"location":"working-with-associations/#bringing-it-all-together-associate_files","title":"Bringing It All Together: associate_files","text":"<p>To associate files seamlessly, employ the associate_files function. Provide two lists of files, and it'll establish links based on the associator you select. It guarantees files from the first list have matches and alerts you if any are unpaired from the second list.</p> <pre><code>def print_hello():\nprint(\"Hello, World!\")\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>sourcelib<ul> <li>associations</li> <li>collect</li> <li>copy</li> <li>defaults<ul> <li>audio</li> <li>compression</li> <li>config</li> <li>default</li> <li>document</li> <li>image</li> <li>video</li> </ul> </li> <li>extension</li> <li>file</li> <li>version</li> </ul> </li> </ul>"},{"location":"reference/sourcelib/","title":"sourcelib","text":""},{"location":"reference/sourcelib/#sourcelib--documentation-for-sourcelib","title":"Documentation for sourcelib","text":"<ul> <li>associations</li> </ul>"},{"location":"reference/sourcelib/associations/","title":"associations","text":""},{"location":"reference/sourcelib/associations/#sourcelib.associations.AnyOneAssociater","title":"<code>AnyOneAssociater</code>","text":"<p>Returns the class name as the association name when called.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; associater = AnyOneAssociater()\n&gt;&gt;&gt; associater(file)\n'AnyOneAssociater'\n</code></pre> Source code in <code>src/sourcelib/associations.py</code> <pre><code>class AnyOneAssociater:\n\"\"\"Returns the class name as the association name when called.\n    Examples:\n        &gt;&gt;&gt; associater = AnyOneAssociater()\n        &gt;&gt;&gt; associater(file)\n        'AnyOneAssociater'\n    \"\"\"\ndef __call__(self, file: File) -&gt; str:\nreturn self.__class__.__name__\n</code></pre>"},{"location":"reference/sourcelib/associations/#sourcelib.associations.AssociatedFiles","title":"<code>AssociatedFiles</code>","text":"<p>             Bases: <code>UserDict</code></p> <p>Represents files associated with a key and mode.</p> <p>Parameters:</p> Name Type Description Default <code>file_key</code> <code>str</code> <p>The key associated with the files.</p> required <code>mode</code> <code>str</code> <p>The mode of the associated files.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; associated_files = AssociatedFiles(file_key=\"key1\", mode=\"mode1\")\n&gt;&gt;&gt; associated_files.add_file(file)\n</code></pre> Source code in <code>src/sourcelib/associations.py</code> <pre><code>class AssociatedFiles(UserDict):\n\"\"\"Represents files associated with a key and mode.\n    Args:\n        file_key (str): The key associated with the files.\n        mode (str): The mode of the associated files.\n    Examples:\n        &gt;&gt;&gt; associated_files = AssociatedFiles(file_key=\"key1\", mode=\"mode1\")\n        &gt;&gt;&gt; associated_files.add_file(file)\n    \"\"\"\ndef __init__(self, file_key, mode):\nself._file_key = file_key\nself._mode = mode\nsuper().__init__({})\ndef add_file(self, file: File):\nif file.mode != self._mode:\nraise ModeMisMatchError(\"Mode does not match\")\nif type(file) not in self or file not in self[type(file)]:\nself.setdefault(file.IDENTIFIER, []).append(file)\n</code></pre>"},{"location":"reference/sourcelib/associations/#sourcelib.associations.Associations","title":"<code>Associations</code>","text":"<p>             Bases: <code>UserDict</code></p> <p>Represents a collection of associated files.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; associations = Associations()\n&gt;&gt;&gt; associations.add_file_key(file_key=\"key1\", mode=\"mode1\")\n</code></pre> Source code in <code>src/sourcelib/associations.py</code> <pre><code>class Associations(UserDict):\n\"\"\"Represents a collection of associated files.\n    Examples:\n        &gt;&gt;&gt; associations = Associations()\n        &gt;&gt;&gt; associations.add_file_key(file_key=\"key1\", mode=\"mode1\")\n    \"\"\"\ndef __init__(self):\nsuper().__init__({})\ndef add_file_key(self, file_key: str, mode):\nself.setdefault(file_key, AssociatedFiles(file_key, mode))\ndef add_file_with_key(self, file_key, file):\nself[file_key].add_file(file)\ndef add_file(self, file: Path, associater: Callable, exact_match: bool, required: bool):\nfile_key = self._associate(file, associater, exact_match)\nif file_key is None and not required:\nreturn\nself[file_key].add_file(file)\ndef _associate(self, file: Path, associater: Callable, exact_match: bool) -&gt; Optional[str]:\nfile_association_key = associater(file)\nfor file_key in self:\nif exact_match:\nif file_key == file_association_key:\nreturn file_key\nelif file_key in file_association_key:\nreturn file_key\nreturn None\n</code></pre>"},{"location":"reference/sourcelib/associations/#sourcelib.associations.StemSplitterAssociater","title":"<code>StemSplitterAssociater</code>","text":"<p>Extracts the association name by splitting the file stem.</p> <p>Parameters:</p> Name Type Description Default <code>split_symbols</code> <code>tuple</code> <p>Tuple of symbols used to split the file stem.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; associater = StemSplitterAssociater(split_symbols=(\"_\", \"-\"))\n&gt;&gt;&gt; file = File(\"/path/to/image_01-version.jpg\")\n&gt;&gt;&gt; associater(file)\n'image'\n</code></pre> Source code in <code>src/sourcelib/associations.py</code> <pre><code>class StemSplitterAssociater:\n\"\"\"Extracts the association name by splitting the file stem.\n    Args:\n        split_symbols (tuple): Tuple of symbols used to split the file stem.\n    Examples:\n        &gt;&gt;&gt; associater = StemSplitterAssociater(split_symbols=(\"_\", \"-\"))\n        &gt;&gt;&gt; file = File(\"/path/to/image_01-version.jpg\")\n        &gt;&gt;&gt; associater(file)\n        'image'\n    \"\"\"\ndef __init__(self, split_symbols: tuple):\nself._split_symbols = split_symbols\nsuper().__init__()\ndef __call__(self, file: File) -&gt; str:\nassociation_name = file.path.stem\nfor split_symbol in self._split_symbols:\nassociation_name = association_name.split(split_symbol)[0]\nreturn association_name\n</code></pre>"},{"location":"reference/sourcelib/associations/#sourcelib.associations.associate_files","title":"<code>associate_files(files1, files2, associations=None, associator=stem_file_associater, exact_match=False)</code>","text":"<p>Associates two lists of files based on an associator.</p> <p>Parameters:</p> Name Type Description Default <code>files1</code> <code>List[File]</code> <p>The first list of files to be associated.</p> required <code>files2</code> <code>List[File]</code> <p>The second list of files to be associated.</p> required <code>associations</code> <code>Optional[Associations]</code> <p>Pre-existing associations. Defaults to None.</p> <code>None</code> <code>associator</code> <code>Callable</code> <p>The function used to determine associations. Defaults to stem_file_associater.</p> <code>stem_file_associater</code> <code>exact_match</code> <code>bool</code> <p>Flag to determine if exact matches are required. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Associations</code> <code>Associations</code> <p>The associations formed from the provided files.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; files1 = [File(\"/path/to/image1.jpg\"), File(\"/path/to/image2.jpg\")]\n&gt;&gt;&gt; files2 = [File(\"/path/to/image1_copy.jpg\"), File(\"/path/to/image3.jpg\")]\n&gt;&gt;&gt; result = associate_files(files1, files2)\n</code></pre> Source code in <code>src/sourcelib/associations.py</code> <pre><code>def associate_files(files1: List[File], files2: List[File], associations: Optional[Associations] = None, \nassociator: Callable = stem_file_associater, exact_match=False) -&gt; Associations:\n\"\"\"Associates two lists of files based on an associator.\n    Args:\n        files1 (List[File]): The first list of files to be associated.\n        files2 (List[File]): The second list of files to be associated.\n        associations (Optional[Associations]): Pre-existing associations. Defaults to None.\n        associator (Callable): The function used to determine associations. Defaults to stem_file_associater.\n        exact_match (bool): Flag to determine if exact matches are required. Defaults to False.\n    Returns:\n        Associations: The associations formed from the provided files.\n    Examples:\n        &gt;&gt;&gt; files1 = [File(\"/path/to/image1.jpg\"), File(\"/path/to/image2.jpg\")]\n        &gt;&gt;&gt; files2 = [File(\"/path/to/image1_copy.jpg\"), File(\"/path/to/image3.jpg\")]\n        &gt;&gt;&gt; result = associate_files(files1, files2)\n    \"\"\"\nif associations is None:\nassociations = Associations()\nfor file1 in files1:\nfile_key = associator(file1)\nassociations.add_file_key(file_key=file_key, mode=file1.mode)\nassociations.add_file(\nfile=file1, associater=associator, exact_match=exact_match, required=True\n)\nfor file2 in files2:\nassociations.add_file(\nfile=file2, associater=associator, exact_match=exact_match, required=False\n)\n# remove unpaired\nremove_keys = []\nfor file_key, files in associations.items():\nif len(list(files.keys())) &lt;= 1 and len(list(dict(files).values())[0]) &lt;= 1:\nremove_keys.append(file_key)\nfor remove_key in remove_keys:\nwarnings.warn(f\"Could not find matching files for key: {remove_key}\")\ndel associations[remove_key]\nreturn associations\n</code></pre>"},{"location":"reference/sourcelib/associations/#sourcelib.associations.stem_file_associater","title":"<code>stem_file_associater(file)</code>","text":"<p>Extracts the stem of the file path.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>File</code> <p>The file whose stem is to be extracted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The stem of the file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; file = File(\"/path/to/image.jpg\")\n&gt;&gt;&gt; stem_file_associater(file)\n'image'\n</code></pre> Source code in <code>src/sourcelib/associations.py</code> <pre><code>def stem_file_associater(file: File) -&gt; str:\n\"\"\"Extracts the stem of the file path.\n    Args:\n        file (File): The file whose stem is to be extracted.\n    Returns:\n        str: The stem of the file.\n    Examples:\n        &gt;&gt;&gt; file = File(\"/path/to/image.jpg\")\n        &gt;&gt;&gt; stem_file_associater(file)\n        'image'\n    \"\"\"\nreturn file.path.stem\n</code></pre>"},{"location":"reference/sourcelib/collect/","title":"collect","text":""},{"location":"reference/sourcelib/collect/#sourcelib.collect.NoSourceFilesInFolderError","title":"<code>NoSourceFilesInFolderError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception raised when no source files are found in a specified folder.</p> Source code in <code>src/sourcelib/collect.py</code> <pre><code>class NoSourceFilesInFolderError(Exception):\n\"\"\"Exception raised when no source files are found in a specified folder.\"\"\"\n</code></pre>"},{"location":"reference/sourcelib/collect/#sourcelib.collect.NonExistentModeInYamlSource","title":"<code>NonExistentModeInYamlSource</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception raised when a mode doesn't exist in the provided YAML source.</p> Source code in <code>src/sourcelib/collect.py</code> <pre><code>class NonExistentModeInYamlSource(Exception):\n\"\"\"Exception raised when a mode doesn't exist in the provided YAML source.\"\"\"\n</code></pre>"},{"location":"reference/sourcelib/collect/#sourcelib.collect.copy_from_yml","title":"<code>copy_from_yml(yaml_source, file_cls, copy_path, modes=(FileMode.default), **kwargs)</code>","text":"<p>Copy files specified in a YAML source to a destination path.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_source</code> <code>Union[Path, dict]</code> <p>The YAML source, either as a path or a dictionary.</p> required <code>file_cls</code> <code>File</code> <p>The class for the files to be copied.</p> required <code>copy_path</code> <code>Path</code> <p>The destination path where files should be copied.</p> required <code>modes</code> <code>Tuple[Enum]</code> <p>The modes associated with the files, default is (FileMode.default,).</p> <code>(default)</code> Source code in <code>src/sourcelib/collect.py</code> <pre><code>def copy_from_yml(\nyaml_source: Union[Path, dict],\nfile_cls: File,\ncopy_path: Path,\nmodes: Tuple[Enum] = (FileMode.default,),\n**kwargs,\n):\n\"\"\"\n    Copy files specified in a YAML source to a destination path.\n    Args:\n        yaml_source (Union[Path, dict]): The YAML source, either as a path or a dictionary.\n        file_cls (File): The class for the files to be copied.\n        copy_path (Path): The destination path where files should be copied.\n        modes (Tuple[Enum], optional): The modes associated with the files, default is (FileMode.default,).\n    \"\"\"\ndata = []\nfor mode in modes:\ndata.extend(\nget_files_from_yaml(\nyaml_source=yaml_source,\nfile_cls=file_cls,\nmode=mode,\n**kwargs,\n)\n)\nfor d in data:\nd.copy(copy_path)\n</code></pre>"},{"location":"reference/sourcelib/collect/#sourcelib.collect.get_associations_from_yaml","title":"<code>get_associations_from_yaml(yaml_source, file_classes, mode=FileMode.default)</code>","text":"<p>Retrieve file associations specified in a YAML source.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_source</code> <code>Union[str, dict]</code> <p>The YAML source, either as a path or a dictionary.</p> required <code>file_classes</code> <code>List[File]</code> <p>The list of file classes to be retrieved.</p> required <code>mode</code> <code>Enum</code> <p>The mode associated with the file, default is FileMode.default.</p> <code>default</code> <p>Returns:</p> Name Type Description <code>Associations</code> <p>The associations of files retrieved based on the criteria specified in the YAML.</p> Source code in <code>src/sourcelib/collect.py</code> <pre><code>def get_associations_from_yaml(\nyaml_source: Union[str, dict],\nfile_classes: List[File],\nmode: Enum = FileMode.default,\n):\n\"\"\"\n    Retrieve file associations specified in a YAML source.\n    Args:\n        yaml_source (Union[str, dict]): The YAML source, either as a path or a dictionary.\n        file_classes (List[File]): The list of file classes to be retrieved.\n        mode (Enum, optional): The mode associated with the file, default is FileMode.default.\n    Returns:\n        Associations: The associations of files retrieved based on the criteria specified in the YAML.\n    \"\"\"\ndata = _get_yaml_data(yaml_source, mode)\nassociations = Associations()\nfor file_key, item in enumerate(data[mode.name]):\nfile_key = str(file_key)\nassociations.add_file_key(file_key=file_key, mode=mode)\nfor _, file_data in file_classes.items():\nfile_cls = file_data[\"class\"]\nkwargs = file_data[\"kwargs\"] if \"kwargs\" in file_data else {}\nfile_identifier = file_cls.IDENTIFIER\nif file_identifier in item:\npath = item[file_identifier].pop(\"path\")\nkwargs.update(item[file_identifier])\nfile = file_cls(mode=mode, path=path, **kwargs)\nassociations.add_file_with_key(file_key=file_key, file=file)\nreturn associations\n</code></pre>"},{"location":"reference/sourcelib/collect/#sourcelib.collect.get_files_from_folder","title":"<code>get_files_from_folder(file_cls, folder, mode=FileMode.default, filters=(), excludes=(), regex=None, recursive=False, **kwargs)</code>","text":"<p>Retrieve files from a specified folder based on criteria.</p> <p>Parameters:</p> Name Type Description Default <code>file_cls</code> <code>File</code> <p>The class for the files to be retrieved.</p> required <code>folder</code> <code>Union[str, Path]</code> <p>The folder from which to retrieve files.</p> required <code>mode</code> <code>Enum</code> <p>The mode associated with the file, default is FileMode.default.</p> <code>default</code> <code>filters</code> <code>List[str]</code> <p>List of strings to filter the files.</p> <code>()</code> <code>excludes</code> <code>List[str]</code> <p>List of strings based on which files should be excluded.</p> <code>()</code> <code>regex</code> <code>str</code> <p>A regular expression to further filter files.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether to search recursively in the folder.</p> <code>False</code> <p>Returns:</p> Type Description <p>List[File]: A list of files retrieved from the folder based on the criteria.</p> Source code in <code>src/sourcelib/collect.py</code> <pre><code>def get_files_from_folder(\nfile_cls: File,\nfolder: Union[str, Path],\nmode: Enum = FileMode.default,\nfilters: List[str] = (),\nexcludes: List[str] = (),\nregex=None,\nrecursive=False,\n**kwargs,\n):\n\"\"\"\n    Retrieve files from a specified folder based on criteria.\n    Args:\n        file_cls (File): The class for the files to be retrieved.\n        folder (Union[str, Path]): The folder from which to retrieve files.\n        mode (Enum, optional): The mode associated with the file, default is FileMode.default.\n        filters (List[str], optional): List of strings to filter the files.\n        excludes (List[str], optional): List of strings based on which files should be excluded.\n        regex (str, optional): A regular expression to further filter files.\n        recursive (bool, optional): Whether to search recursively in the folder.\n    Returns:\n        List[File]: A list of files retrieved from the folder based on the criteria.\n    \"\"\"\nall_sources = []\nfolder = Path(folder)\nfor extension in file_cls.EXTENSIONS:\npaths = (\nfolder.rglob(\"*\" + extension) if recursive else folder.glob(\"*\" + extension)\n)\nsources = get_files_from_paths(\nfile_cls, mode, paths, filters, excludes, regex, **kwargs\n)\nall_sources.extend(sources)\nif len(all_sources) == 0:\nraise NoSourceFilesInFolderError(file_cls, filters, excludes, regex, folder)\nreturn all_sources\n</code></pre>"},{"location":"reference/sourcelib/collect/#sourcelib.collect.get_files_from_path","title":"<code>get_files_from_path(file_cls, path, mode=FileMode.default, **kwargs)</code>","text":"<p>Retrieve files from a single path.</p> <p>Parameters:</p> Name Type Description Default <code>file_cls</code> <code>File</code> <p>The class for the files to be retrieved.</p> required <code>path</code> <code>str</code> <p>The path from which to retrieve files.</p> required <code>mode</code> <code>Enum</code> <p>The mode associated with the file, default is FileMode.default.</p> <code>default</code> <p>Returns:</p> Type Description <p>List[File]: A list of files retrieved from the path.</p> Source code in <code>src/sourcelib/collect.py</code> <pre><code>def get_files_from_path(\nfile_cls: File, path: str, mode: Enum = FileMode.default, **kwargs\n):\n\"\"\"\n    Retrieve files from a single path.\n    Args:\n        file_cls (File): The class for the files to be retrieved.\n        path (str): The path from which to retrieve files.\n        mode (Enum, optional): The mode associated with the file, default is FileMode.default.\n    Returns:\n        List[File]: A list of files retrieved from the path.\n    \"\"\"\nreturn get_files_from_paths(file_cls, mode, [path], [], [], None, **kwargs)\n</code></pre>"},{"location":"reference/sourcelib/collect/#sourcelib.collect.get_files_from_paths","title":"<code>get_files_from_paths(file_cls, mode, paths, filters, excludes, regex=None, **kwargs)</code>","text":"<p>Retrieve files from the provided paths based on specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>file_cls</code> <code>File</code> <p>The class for the files to be retrieved.</p> required <code>mode</code> <code>Enum</code> <p>The mode associated with the file.</p> required <code>paths</code> <code>List[str]</code> <p>The list of paths from which to retrieve files.</p> required <code>filters</code> <code>List[str]</code> <p>A list of strings to filter the files.</p> required <code>excludes</code> <code>List[str]</code> <p>A list of strings based on which files should be excluded.</p> required <code>regex</code> <code>str</code> <p>A regular expression to further filter files.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[File]: A list of files retrieved based on the criteria.</p> Source code in <code>src/sourcelib/collect.py</code> <pre><code>def get_files_from_paths(\nfile_cls: File,\nmode: Enum,\npaths: List[str],\nfilters: List[str],\nexcludes: List[str],\nregex=None,\n**kwargs,\n):\n\"\"\"\n    Retrieve files from the provided paths based on specified criteria.\n    Args:\n        file_cls (File): The class for the files to be retrieved.\n        mode (Enum): The mode associated with the file.\n        paths (List[str]): The list of paths from which to retrieve files.\n        filters (List[str]): A list of strings to filter the files.\n        excludes (List[str]): A list of strings based on which files should be excluded.\n        regex (str, optional): A regular expression to further filter files.\n    Returns:\n        List[File]: A list of files retrieved based on the criteria.\n    \"\"\"   \nfiles = []\npaths = set(paths)\nfor path in paths:\npath = str(Path(path).expanduser())\nif any((exclude in path for exclude in excludes)):\ncontinue\nif filters and not any((filter in path for filter in filters)):\ncontinue\nif regex is not None and not re.search(regex, path):\ncontinue\nfiles.append(file_cls(mode=mode, path=path, **kwargs))\nreturn sorted(files, key=lambda k: k.path)\n</code></pre>"},{"location":"reference/sourcelib/collect/#sourcelib.collect.get_files_from_yaml","title":"<code>get_files_from_yaml(yaml_source, file_cls, mode=FileMode.default, filters=(), excludes=(), regex=None, **kwargs)</code>","text":"<p>Retrieve files specified in a YAML source.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_source</code> <code>Union[str, dict]</code> <p>The YAML source, either as a path or a dictionary.</p> required <code>file_cls</code> <code>File</code> <p>The class for the files to be retrieved.</p> required <code>mode</code> <code>Enum</code> <p>The mode associated with the file, default is FileMode.default.</p> <code>default</code> <code>filters</code> <code>Tuple[str]</code> <p>Tuple of strings to filter the files.</p> <code>()</code> <code>excludes</code> <code>Tuple[str]</code> <p>Tuple of strings based on which files should be excluded.</p> <code>()</code> <code>regex</code> <code>str</code> <p>A regular expression to further filter files.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[File]: A list of files retrieved based on the criteria specified in the YAML.</p> Source code in <code>src/sourcelib/collect.py</code> <pre><code>def get_files_from_yaml(\nyaml_source: Union[str, dict],\nfile_cls: File,\nmode: Enum = FileMode.default,\nfilters=(),\nexcludes=(),\nregex=None,\n**kwargs,\n):\n\"\"\"\n    Retrieve files specified in a YAML source.\n    Args:\n        yaml_source (Union[str, dict]): The YAML source, either as a path or a dictionary.\n        file_cls (File): The class for the files to be retrieved.\n        mode (Enum, optional): The mode associated with the file, default is FileMode.default.\n        filters (Tuple[str], optional): Tuple of strings to filter the files.\n        excludes (Tuple[str], optional): Tuple of strings based on which files should be excluded.\n        regex (str, optional): A regular expression to further filter files.\n    Returns:\n        List[File]: A list of files retrieved based on the criteria specified in the YAML.\n    \"\"\"\ndata = _get_yaml_data(yaml_source, mode)\nfile_identifier = file_cls.IDENTIFIER\npaths = []\nfor item in data[mode.name]:\nif file_identifier in item:\npaths.append(item[file_identifier].pop(\"path\"))\nkwargs.update(item[file_identifier])\nreturn get_files_from_paths(\nfile_cls, mode, paths, filters, excludes, regex, **kwargs\n)\n</code></pre>"},{"location":"reference/sourcelib/copy/","title":"copy","text":""},{"location":"reference/sourcelib/extension/","title":"extension","text":""},{"location":"reference/sourcelib/file/","title":"file","text":""},{"location":"reference/sourcelib/version/","title":"version","text":""},{"location":"reference/sourcelib/defaults/","title":"defaults","text":""},{"location":"reference/sourcelib/defaults/audio/","title":"audio","text":""},{"location":"reference/sourcelib/defaults/compression/","title":"compression","text":""},{"location":"reference/sourcelib/defaults/config/","title":"config","text":"<p>This module provides a set of predefined extensions for various configuration file formats and generates a default file class for the current module.</p> <p>Attributes:</p> Name Type Description <code>CONFIGURATION_EXTENSION</code> <code>Extension</code> <p>Defines the extension for '.conf' files.</p> <code>INITIALIZATION_EXTENSION</code> <code>Extension</code> <p>Defines the extension for '.ini' initialization files.</p> <code>CONFIG_FILE_EXTENSION</code> <code>Extension</code> <p>Defines the extension for '.cfg' configuration files.</p> <code>YET_ANOTHER_MARKUP_LANGUAGE_EXTENSION</code> <code>Extension</code> <p>Defines the extensions for '.yaml' and '.yml' files.</p> <code>JAVASCRIPT_OBJECT_NOTATION_EXTENSION</code> <code>Extension</code> <p>Defines the extension for '.json' files.</p> <code>TOMS_OBVIOUS_MINIMAL_LANGUAGE_EXTENSION</code> <code>Extension</code> <p>Defines the extension for '.toml' files.</p> <code>ConfigFile</code> <code>Type[FileType]</code> <p>A default file class generated for the current module.</p>"},{"location":"reference/sourcelib/defaults/default/","title":"default","text":""},{"location":"reference/sourcelib/defaults/document/","title":"document","text":""},{"location":"reference/sourcelib/defaults/image/","title":"image","text":""},{"location":"reference/sourcelib/defaults/video/","title":"video","text":""}]}